{
  "name": "connect-keycloak",
  "version": "0.0.13",
  "description": "Keycloak Connect Middleware",
  "main": "index.js",
  "scripts": {
    "test": "node_modules/jasmine/bin/jasmine.js",
    "build": "node_modules/grunt-cli/bin/grunt"
  },
  "author": "",
  "license": "Apache-2.0",
  "devDependencies": {
    "grunt": "^0.4.5",
    "grunt-cli": "^0.1.13",
    "grunt-contrib-jshint": "^0.10.0",
    "grunt-contrib-uglify": "^0.6.0",
    "grunt-doxx": "^0.1.2",
    "grunt-gh-pages": "^0.9.1",
    "grunt-touch": "^0.1.0",
    "jasmine": "^2.1.1"
  },
  "dependencies": {
    "keycloak-auth-utils": "0.0.13",
    "q": "^1.1.2"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/keycloak/keycloak-nodejs.git"
  },
  "bugs": {
    "url": "http://github.com/keycloak/keycloak-nodejs/issues"
  },
  "readme": "# Keycloak\n\n[Keycloak](http://keycloak.jboss.org/) is a standalone authentication\nserver, akin to a standalone database.  It provides hooks for federated\nauthentication, including authenticating against various social networks\nand OAuth providers (G+, Facebook, etc).\n\nThis module makes it simple to implement a Node.js Connect-friendly\napplication that uses Keycloak for its authentication and authorization needs.\n\n## Install\n\n    npm install --save connect-keycloak\n\n## Instantiate a Keycloak\n\nThe `Keycloak` class provides a central point for configuration\nand integration with your application.  The simplest creation\ninvolves no arguments.\n\n    var keycloak = new Keycloak()\n\nBy default, this will locate a file named `keycloak.json` alongside\nthe main executable of your application to initialize keycloak-specific\nsettings (public key, realm name, various URLs).  The `keycloak.json` file\nis obtained from the Keycloak Admin Console.\n\nInstantiation with this method results in all of the reasonable defaults\nbeing used.  Normally, though, if you wish to use web sessions to manage\nserver-side state for authentication, you will need to initialize the\n`KeyCloak(...)` with at least a `store` parameter, passing in the actual\nsession store that `express-session` is using.\n\n    var session = require('express-session');\n    var memoryStore = new session.MemoryStore();\n\n    var keycloak = new Keycloak({ store: memoryStore });\n\n## Install middleware\n\nOnce instantiated, install the middleware into your connect-capable app:\n\n    var app = express();\n\n    app.use( keycloak.middleware() );\n\n## Protect resources\n\n### Simple authentication\n\nTo enforce that a user must be authenticated before accessing a resource,\nsimply use a no-argument version of `keycloak.protect()`:\n\n    app.get( '/complain', keycloak.protect(), complaintHandler );\n\n### Role-based authorization\n\nTo secure a resource with an application role for the current app:\n\n    app.get( '/special', keycloak.protect('special'), specialHandler );\n\nTo secure a resource with an application role for a *different* app:\n\n    app.get( '/extra-special', keycloak.protect('other-app:special', extraSpecialHandler );\n\nTo secure a resource with a realm role:\n\n    app.get( '/amin', keycloak.protect( 'realm:admin' ), adminHandler );\n\n### Advanced authorization\n\nTo secure resources based on parts of the URL itself, assuming a role exists \nfor each section:\n\n    function protectBySection(token, request) {\n      return token.hasRole( request.params.section );\n    }\n\n    app.get( '/:section/:page', keycloak.protect( protectBySection ), sectionHandler );\n\n## Additional URLs\n\n### Explicit user-triggered logout\n\nBy default, the middleware catches calls to `/logout` to send the user through a\nKeycloak-centric logout workflow. This can be changed by specifying a `logout`\nconfiguration parameter to the `middleware()` call:\n\n    app.use( keycloak.middleware( { logout: '/logoff' } );\n\n### Keycloak Admin Callbacks\n\nAlso, the middleware supports callbacks from the Keycloak console to logout a single\nsession or all sessions.  By default, these type of admin callbacks occur relative\nto the root URL of `/` but can be changed by providing an `admin` parameter \nto the `middleware()` call:\n\n    app.use( keycloak.middleware( { admin: '/callbacks' } );\n\nNormally this does not need to be changed.\n\n# A full example\n\nThe `connect-keycloak-example` has this example:\n\n## `example.js`\n\n    var Keycloak = require('connect-keycloak');\n\n    var express = require('express');\n    var session = require('express-session')\n\n    var app = express();\n\n    // Allow passing in a port from the command-line.\n    var p = 3000;\n    if ( process.argv.length >= 3 ) {\n      p = Number( process.argv[2] );\n    }\n\n    app.set('port', p );\n\n    // Create a session-store to be used by both the express-session\n    // middleware and the keycloak middleware.\n    \n    var memoryStore = new session.MemoryStore();\n    \n    app.use( session({\n      secret: 'aaslkdhlkhsd',\n      resave: false,\n      saveUninitialized: true,\n      store: memoryStore,\n    } ))\n    \n    \n    // Provide the session store to the Keycloak so that sessions\n    // can be invalidated from the Keycloak console callback.\n    //\n    // Additional configuration is read from keycloak.json file\n    // installed from the Keycloak web console.\n    \n    var keycloak = new Keycloak({\n      store: memoryStore\n    });\n    \n    // Install the Keycloak middleware.\n    //\n    // Specifies that the user-accessible application URL to\n    // logout should be mounted at /logout\n    //\n    // Specifies that Keycloak console callbacks should target the\n    // root URL.  Various permutations, such as /k_logout will ultimately\n    // be appended to the admin URL.\n    \n    app.use( keycloak.middleware( {\n      logout: '/logout',\n      admin: '/',\n    } ));\n    \n    \n    // A normal un-protected public URL.\n    \n    app.get( '/', function(req,resp) {\n      resp.send( \"Howdy!\" );\n    } )\n    \n    \n    // A protection guard can take up to 3 arguments, and is passed\n    // the access_token, the HTTP request and the HTTP response.\n    //\n    // The token can be tested for roles:\n    //\n    // * 'foo' is a simple application role 'foo' for the current application\n    // * 'bar:foo' is an application role 'foo' for the application 'bar'\n    // * 'realm:foo' is a realm role 'foo' for the application's realm\n    //\n    // A protection guard can be passed to keycloak.protect(...) for any\n    // URL.  If it returns true, then the request is allowed.  If false,\n    // access will be denied.\n    \n    var groupGuard = function(token, req, resp) {\n      return token.hasRole( req.params.group );\n    }\n    \n    // The keycloak.protect(...) function can take a guard function to perform\n    // advanced protection of a URL.\n    //\n    // Additionally (not shown) it can take simple string role specifier identical\n    // to those used above by token.hasRole(...).\n    //\n    // In all cases, if a user is not-yet-authenticated, the Keycloak token authentication\n    // dance will begin by redirecting the user to the Keycloak login screen.  If\n    // authenticated correctly with Keycloak itself, the workflow continues to exchange\n    // the Keycloak-provided for a signed Keycloak access_token.\n    //\n    // A user's authentication may be provided through the HTTP session (via cookies)\n    // or through Bearer authentication header.\n    //\n    // In the event a user is authenticated, but his access-token has expired, if a\n    // refresh-token is available, the middleware will attempt to perform a refresh.\n    //\n    // All of the above workflow is transparent to the user, who ultimately will\n    // access the requested resource or be denied, modulo an initial login through\n    // Keycloak itself.\n    \n    app.get( '/:group/:page', keycloak.protect( groupGuard ), function(req,resp) {\n      resp.send( 'Page: ' + req.params.page + ' for Group: ' + req.params.group + '<br><a href=\"/logout\">logout</a>');\n    })\n    \n    // A simple keycloak.protect() ensures that a user is authenticated\n    // but provides no additional RBAC protection.\n    \n    app.get( '/:page', keycloak.protect(), function(req,resp) {\n      resp.send( 'Page: ' + req.params.page + '<br><a href=\"/logout\">logout</a>');\n    } );\n    \n    var server = app.listen(app.settings.port, function () {\n      var host = server.address().address\n      var port = server.address().port\n      console.log('Example app listening at http://%s:%s', host, port)\n    })\n    \n## `keycloak.json`\n\nAlongside the `example.js` lives `keycloak.json` obtained from our Keycloak\nadmin console when we provisioned this app.\n\n\n    {\n      \"realm\": \"example-realm\",\n      \"realm-public-key\": \"MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCrVrCuTtArbgaZzL1hvh0xtL5mc7o0NqPVnYXkLvgcwiC3BjLGw1tGEGoJaXDuSaRllobm53JBhjx33UNv+5z/UMG4kytBWxheNVKnL6GgqlNabMaFfPLPCF8kAgKnsi79NMo+n6KnSY8YeUmec/p2vjO2NjsSAVcWEQMVhJ31LwIDAQAB\",\n      \"auth-server-url\": \"http://localhost:8080/auth\",\n      \"ssl-required\": \"none\",\n      \"resource\": \"example-app\",\n      \"credentials\": {\n        \"secret\": \"89efcbdf-ee95-4292-bbd9-29304e6744c7\"\n      }\n    }\n\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/keycloak/keycloak-nodejs",
  "_id": "connect-keycloak@0.0.13",
  "_shasum": "ef6fdfb95954e1b67416d5f7b9842bf8e5456913",
  "_from": "connect-keycloak@",
  "_resolved": "https://registry.npmjs.org/connect-keycloak/-/connect-keycloak-0.0.13.tgz"
}
